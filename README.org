* monstar
A C++ library for MONitoring an application and sending data to grafana to generate STAtistics and Reporting.


** Purpose

   MONSTAR is a library I created to simplify monitoring C++
   applications using Grafana together with Elasticsearch and
   Graphite.

** Use Cases

   Monstar currently supports three use cases:

   - In instant simple numeric information in Graphite.
   - In instant scope benchmarking.
   - Event based message transation to time-series data.  This
     currently only supports Elasticsearch data.

   The tutorial section below gives examples of implementing these
   three use cases.

** Tutorials

*** Configuration:

**** Graphite
	The simple_recorder and scoped_benchmarker report whenever called
	to graphite.  You can call ~configure_graphite(std::string ip,
	std::string port, std::string prefix)~ to configure the following:
	  - ~ip~ :: the url or ip address of the graphite server you are
             posting to.  Default is 127.0.1
	  - ~port~ :: the port number for the graphite server, default
               is 2003.
	  - ~prefix~ :: This allows you to set a global prefix all
                 graphite instances.  Whatever prefix you specify will
                 be applied to the beginning of the path of all
                 graphite posts.
**** Elasticsearch.

	 The timeseries api takes messages and translates them into
	 timeseries information which is sent to an elasticsearch server.
	 This ~configure_elasticsearch(std::string es_ip, std::es_port, int
	 period)~ method  allows you to configure:

	 - ~ip~ :: The ip address or path to the Elasticsearch
            server. Default is 127.0.0.1.
	 - ~port~ :: the port of the Elasticsearch server. Default is 9200.
	 - ~period~ :: The interval, in seconds, over which the library
                should send messages.  Default is 20s.

*** Recording simple numeric information in graphite

	In the simplest case there's a regularly recurring piecee of code
	containing some numeric quantity you would like to access.

**** TODO get to build and test when you have net access.
	#+BEGIN_SRC C++

	#include "monstar/SimpleRecorder.hpp"

	void rand_recorder()
	{
	static monstar::simple_recorder rr("example.rand");
	rr(rand());
	}

	int main()
	{
	while(true){
	rand_recorder();
	std::this_thread.sleep_for(1s);
	}


	#+END_SRC


*** scoped_benchmarker

	Let's say you have a method or class, and you want to know its
	lifetime.  You can use a ScopedBenchmarker for this.

	@todo check graphite docu for correctness of this information.


*** Events to timeseries information

	While the simple_recorder and scoped_timer are handy, they are
	also pretty trivial.  They are subject to the same restrictions as
	Graphite -- they can only be used to store numeric timeseries
	data.  Since the only record information on calling, they are only
	useful in areas of code which are called at regular and
	appropriate spaced intervals (with Graphite taking care of
	agglomeration).

	By contrast, the notification interface allows translating
	irregular notifications into timeseries information.  It uses
	Elasticsearchh as a backend, meaning we have more sophisticated
	analysis options.  We'll work through a couple of examples here.

	In order to translate from notifications to timeseries near-time
	messages, a container of timeseries-generators is maintained.  The
	notification sents messages to the



** Warning:

   While I hope this is already useful for people, the project is not
   partiularly mature.  I am actively developing and testing the
   library, so the interface is subject to change, and there's
   probably a lot of errors and suboptimal stuff.  Feedbacck and pull
   requests are welcome!
